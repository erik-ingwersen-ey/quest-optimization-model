"""Extra output scripts for creating output columns to optimization model.
"""
from typing import Union
import logging
import pandas as pd

from optimization.constants import Columns

# Possible usage status.
in_use = "in use"
in_inventory = "in inventory"
not_found = "not found"

# Expire status.
surplus = "surplus"
shortage = "shortage"
less_than_min = "less than min"
more_than_min = "more than min"


def qty_to_optimize(df_inventory: pd.DataFrame, item_id: object) -> tuple:
    """Calculates the maximum amount of inventory that can be optimized in terms of ``Items to Expire`` and ``Inventory Balance``

    This method is called by :meth:`optimization.model.main.ModelOptimization.optimize<optimization.model.optimizer.ModelOptimization.optimize>`
    in order to calculate the theoretical maximum quantity that can be optimized for a given ``Item ID`` in terms of
    ``Items to Expire`` and ``Inventory Balance``.

    In order to obtain these values (``Items to Expire`` and ``Inventory Balance`` theoretical maximum) we filter the inventory
    using the ``Item ID`` column, then we group all values by business unit, aggregating into sepparate fields the negative amount
    of inventory balance from the positive part. Then we aggregate another time by ``Item ID``. For inventory balance,
    the **theoretical maximum inventory quantity that can be optimized will be the smallest number** between ``Surplus`` and ``Shortage``
    (since we can only reduce shortage from one BU by eliminating surplus from another).

    Parameters
    ----------
    df_inventory : pd.DataFrame
        Inventory DataFrame.
    item_id : object
        ``Item ID`` that we want to determine the maximum inventory that can be optimized.

    Returns
    -------
    tuple : Total $ amount of inventory balance and items to expire (in that specific order) that can be optimized.

    """
    item_df = df_inventory[df_inventory[Columns.item_id] == item_id] \
        .groupby(Columns.inv_bu, as_index=False) \
        .agg({Columns.doi_balance: 'sum', Columns.items_to_expire: 'sum', Columns.price: 'mean'})

    shortage = 0
    surplus = 0
    items_to_expire = 0

    for _, row in item_df.iterrows():
        if row[Columns.doi_balance] < 0:
            shortage += row[Columns.doi_balance] * -1 * row[Columns.price]
        else:
            surplus += row[Columns.doi_balance] * row[Columns.price]

        if row[Columns.items_to_expire] > 0:
            items_to_expire += row[Columns.items_to_expire] * row[Columns.price]

    return min(shortage, surplus), items_to_expire


def extra_output(inventory_report: pd.DataFrame) -> pd.DataFrame:
    """Create extra output table.

    **Steps:**
        1. Select necessary columns.

        2. Rename selected columns according to their specified names.

    Parameters
    ----------
    inventory_report : pd.DataFrame
        Original inventory report.

    Returns
    -------
    pd.DataFrame : Extra output table.

    """
    columns_needed = [
        Columns.report_date,
        Columns.inv_bu,
        Columns.item_id,
        Columns.lot_id,
        Columns.lot_qty_on_hand,
        Columns.bu_qty_on_hand,
        Columns.price, ]

    columns_rename = {
        Columns.report_date: "Report Date",
        Columns.inv_bu: "Inv BU",
        Columns.item_id: "Item ID",
        Columns.lot_id: "Lot ID",
        Columns.lot_qty_on_hand: "Lot Qty on Hand",
        Columns.bu_qty_on_hand: "BU Qty on Hand",
        Columns.price: "STD Price", }

    inventory_report[Columns.inv_bu] = inventory_report[Columns.inv_bu].astype(int).astype(str)
    inventory_report[Columns.item_id] = inventory_report[Columns.item_id].astype(int).astype(str)

    return (inventory_report[columns_needed]).rename(columns=columns_rename)


def transfer_reason(inventory_report: pd.DataFrame, optimization_results: pd.DataFrame) -> pd.DataFrame:
    """
    Populate ``Transfer Recommendation Reason`` column.

    Parameters
    ----------
    inventory_report : pd.DataFrame
        Original inventory report **after data ingestion and validation processes**
    optimization_results : pd.DataFrame
        Transfer recommendations generated by the optimization model

    Returns
    -------
    pd.DataFrame
        Transfer results with added ``Transfer Recommendation Reason`` column

    Tip
    ---
    The cleaned version of inventory report is obtained inside \
    :meth:`optimization.model.main.main()<optimization.model.main.main>` method.

    """
    optimization_results["Transfer Recommendation Reason"] = optimization_results.apply(
        lambda row: classify_row(row, inventory_report), axis=1)
    return optimization_results


def classify_row(row: pd.Series, inventory_report: pd.DataFrame) -> str:
    """Used for classifying each transfer (row) generated by the optimization model"""

    sender_status, receiver_status = get_status(inventory_report, row, "both")

    if row["Source Lot ID"] == "NONLOT":
        return "Surplus at SoBU (non-lot)"

    elif row["Sender Lot Items to Expire"] > 0:
        if row["Receiver BU's SKU Current DOI"] > row["Receiver BU's SKU Target DOI"]:
            curr_doi = surplus  # same as "surplus"
        else:
            curr_doi = shortage  # same as "shortage"

        min_days_status = min_days_apply(row, inventory_report)
        return expire_rows(receiver_status, curr_doi, min_days_status)

    else:
        return surplus_rows(receiver_status, sender_status)


def get_status(inventory_report: pd.DataFrame, row: pd.Series, what: str = "both") -> Union[str, tuple]:
    """Get status of Lot for receiver and sender BU.

    Parameters
    ----------
    inventory_report : pd.DataFrame
        Table with inventory report.
    row : pd.Series
        Row from optimization report we're analyzing.
    what : str, optional
        Get status for both receiver and sender or only receiver or receiver DOI status, by default "both".

    Returns
    -------
    Union[str, tuple] : Status of lot at receiver and sender BU if objective function is set to 'both', else returns only
    in one of them
    """
    receiver_bu = row["Receiver BU ID"]
    item_id, lot_id = row["Item ID"], row["Source Lot ID"]
    receiver_status = FindLot(inventory_report, receiver_bu, item_id, lot_id).lot_usage()

    if what == "both":
        sender_bu = row["Sender BU ID"]
        sender_status = FindLot(inventory_report, sender_bu, item_id, lot_id).lot_usage()
        return sender_status, receiver_status

    elif what == "expire":
        return FindLot(inventory_report, receiver_bu, item_id, lot_id).expire_status(row["Receiver BU's SKU Current DOI"])

    return receiver_status


def expire_rows(receiver_status: str, curr_doi: str, min_days: str) -> str:
    """Populates ``Transfer Recommendation Reason`` column, after determining that transfers
     had a reduction o **items to expire**.

    Parameters
    ----------
    receiver_status : str
        Receiver status contains information about the situation of a given item at the receiver end. Can be:

        - ``in use`` : Receiver has that given item from that given Lot and is currently using it.

        - ``in inventory`` : Receiver has that given item **from that given Lot** but is **NOT** currently using it.

        - ``not found`` :  Receiver doesn't have that given item **from that given Lot** (and is not using it since it \
         doesn't have that Lot). _

    curr_doi : str
        String with information about inventory balance from receiver BU. \
        Can be:

        - ``surplus`` : Receiver business unit has surplus, therefore in the transfer recommendation reason, \
        we will add at the end of the transfer reason "... at surplus ReBU"

        - ``shortage`` : Receiver business unit has shortage, therefore in the transfer recommendation reason, \
        we will add at the end of the transfer reason "... at deficit ReBU"

    min_days : str
        Minimum days of supply

    Returns
    -------
    Transfer reason to be added to the column ``Transfer Recommendation Reason`` : str

    Note
    ----
    ``minimum days of transfers applies`` is a metric based on a column from the original report. ``minimum days of transfers applies`` means that the total transferred \
    items accounts for an increase at the receiver days of inventory that is bigger than this ``minimum days of transfers`` threshold. For example, if the ``minimum days of transfers`` \
    is 14 days and you send to a receiver business unit 25 items and when we divide those transfers by the receivers ``Avg Daily Consumption Rate`` results on total increase on days of inventory \
    of 30 days (in this case this would happen if ``Avg Daily Consumption Rate`` = 0.833 Items/day) then ``minimum days of transfers applies``.

    """

    # Rule 1
    if ((receiver_status == in_inventory) or (receiver_status == in_use)) and (curr_doi == shortage):
        return "Lot expires before SoBU use; lot on hand at deficit ReBU"
    # Rule 2
    elif (min_days == more_than_min) and (receiver_status == not_found) and (curr_doi == shortage):
        return "Lot expires before SoBU use; lot NOT at deficit ReBU (minimum days applies)"
    # Rule 3
    elif (receiver_status == in_use) and (curr_doi == surplus):
        return "Lot expires before SoBU use; lot in use at surplus ReBU"
    # Rule 4
    elif (min_days == less_than_min) and (receiver_status == not_found) and (curr_doi == shortage):
        return "Lot expires before SoBU use; lot NOT at deficit ReBU (less than minimum days applies)"
    # New Expire Rule 1
    elif (receiver_status == in_inventory) and (curr_doi == surplus):
        return "Lot expires before SoBU use; lot in inventory at surplus ReBU"
    # New Expire Rule 2
    elif (receiver_status == not_found) and (curr_doi == surplus):
        return "Lot expires before SoBU use; lot not found at surplus ReBU"


def surplus_rows(receiver_status: str, sender_status: str) -> str:
    """Classify rows with surplus at sender BU.

    Parameters
    ----------
    receiver_status : str
        Status of Lot for receiver BU.
    sender_status : str
        Status of Lot for sender BU.

    Returns
    -------
    str : Recommendation reason classification for surplus

    """
    # Rule 5
    if (sender_status == in_inventory) and (receiver_status == in_use):
        return "Surplus at SoBU (lot NOT in use); lot in use at deficit ReBU"
    # Rule 6
    elif (sender_status == in_inventory) and (receiver_status == in_inventory):
        return "Surplus at SoBU (lot NOT in use); lot in inventory at deficit ReBU"
    # Rule 7
    elif (sender_status == in_use) and (receiver_status == in_use):
        return "Surplus at SoBU (lot in use); lot in use at deficit ReBU"
    # Rule 8
    elif (sender_status == in_use) and (receiver_status == in_inventory):
        return "Surplus at SoBU (lot in use); lot in inventory at deficit ReBU"
    # New Surplus Rule 1
    elif (sender_status == in_use) and (receiver_status == not_found):
        return "Surplus at SoBU (lot in use); lot not found at deficit ReBU"
    # New Surplus Rule 2
    elif (sender_status == in_inventory) and (receiver_status == not_found):
        return "Surplus at SoBU (lot NOT in use); lot not found at deficit ReBU"


def min_days_apply(row: pd.Series, inventory_report: pd.DataFrame) -> str:
    """Check if transfer recommendation is smaller than minimum threshold
    """

    min_days_inv = min(
        inventory_report[(row["Receiver BU ID"] == inventory_report[Columns.inv_bu])
                         & (row["Item ID"] == inventory_report[Columns.item_id])][Columns.minimum_days_of_inventory_for_lot])

    if min_days_inv * row["Receiver Average Weekly Use"] / 7 >= row["Item Quantity to transfer"]:
        return more_than_min  # same as "more than min"

    return less_than_min  # same as "less than min"


class FindLot:
    """Determine Lot status (in terms of usage and availability) at receiver business units,
     for each line of the optimization model results.

    Class determines if item from a given Lot is found or not
    on receiver business unit based on transfer recommendations and inventory reports.
    If Lot exists on receiver BU, we then determine its usage status that can be one of the following values:

    * **found:** BU has Lot we're analyzing.

        * **in use:** BU is currently using that Lot.

        * **in inventory:** BU is not currently using that Lot.

    * **not found:** Lot is not found at the BU we're analyzing. (Can only happen for receiving BU's).

    Attributes
    ----------
    inventory_report : pd.DataFrame
        Inventory report table with information about all items from all BU's.
    inv_bu : object
        Business Unit ID we're analyzing.
    item_id : object
        Item ID we're analyzing.
    lot_id : object
        Lot ID we're analyzing.

    """

    def __init__(self, inventory_report: pd.DataFrame, inv_bu: object, item_id: object, lot_id: object):

        self.inventory_report = inventory_report
        self.inv_bu = inv_bu
        self.item_id = item_id
        self.lot_id = lot_id

    def get_status(self, level: str = "lot") -> pd.DataFrame:
        """Return table with matching Item or Lot IDs.

        If level is set to lot, filter inventory report by Item ID, Lot ID and BU ID.
        Else filter by Item and BU ID only.

        Parameters
        ----------
        level : str, optional
            Level that we want to filter inventory report, by default "lot".

        Returns
        -------
        pd.DataFrame
            Records with matching criteria.

        Raises
        ------
        AssertionError
            Raises an error when value passed to level is not `lot` or `item`.

        """
        try:
            assert level in ["lot", "item"]
            status = self.inventory_report[(self.inventory_report[Columns.inv_bu] == self.inv_bu)
                                           & (self.inventory_report[Columns.item_id] == self.item_id)]
            if level == "item":
                return status
            return status[status[Columns.lot_id] == self.lot_id]

        except AssertionError:
            logging.error("Variable level can be equal to lot or item. {} not supported.".format(level))

    def lot_usage(self):
        """Method used to determine if lot is in use, in inventory or not found at receiving business unit

        Rules for determining if lot status:
        1. If column bu_item_last_lot_depleted equals to "Y", the Lot is in use

        2. If no Lot for a given Item at the business unit has column bu_item_last_lot_depleted equal to "Y", then \
            check column date_lot_added_to_bu_inv. If its value is the oldest among lots for that same \
            item/business unit, then consider it as being in use

        3. If Lot has column bu_item_last_lot_depleted not equal to "Y" but some other Lot does, and if method \
        ``lot_status`` doesn't return empty, then lot is in inventory.

        4. If method ``lot_status`` returns empty, then lot is not found

        Returns
        -------
        Literal[in_use, in_inventory, not_found] : Returns one possible three values for lot usage \
        (in use, inventory of not found)

        """
        lot_status = self.get_status(level="lot")
        item_status = self.get_status(level="item")

        if isinstance(lot_status, pd.DataFrame) and isinstance(item_status, pd.DataFrame):
            if lot_status.shape[0] == 0:
                return not_found  # same as "not found"

            else:
                if lot_status[Columns.bu_item_last_lot_depleted].iloc[0] == 'Y':
                    return in_use   # same as "in use"
                else:
                    if item_status[item_status[Columns.bu_item_last_lot_depleted] == 'Y'].shape[0] == 0 and \
                            lot_status[Columns.date_lot_added_to_bu_inv].iloc[0] == min(item_status[Columns.date_lot_added_to_bu_inv]):
                        return in_use  # same as "in use"

            return in_inventory  # same as "in inventory"

    def expire_status(self, receiver_doi: int) -> str:
        """Get status for transfers made due to expiring items"""

        item_status = self.get_status(level="item")
        if isinstance(item_status, pd.DataFrame):
            minimum_days_apply = (item_status.loc[0, Columns.minimum_days_of_inventory_for_lot])
            if receiver_doi <= 0:
                if minimum_days_apply < 0:
                    return less_than_min  # same as "less than min"
                else:
                    return more_than_min  # same as "more than min"

            return surplus  # same as "surplus"
